mutate(Conc_Droplet = Conc_Sum  * (as.numeric(Initial_Size) * 1e-6)^3) %>%
# and then sum concentrations across size for a given replicate
group_by(ACH, Replicate) %>%
mutate(Drop_Vol_Ratio = sum(Conc_Droplet))%>%
ungroup()
temp_t_exit_df <- unique(temp_t_exit_df[, c("ACH", "Replicate", "RH", "v", "Drop_Vol_Ratio")])
# column for the time spent in toilet
temp_t_exit_df$t_dur <- exit_time - t_0_iter
# store the data for each ach
drop_vol_ratio_df <- bind_rows(drop_vol_ratio_df, temp_t_exit_df)
}
# set the parameter values for each t_0 iteration
temp_t_0_df <- drop_vol_ratio_df %>%
mutate(
RH = RH,
v = v,
Drop_Vol_Ratio = Drop_Vol_Ratio,
Arrangement = arrangement,
Gender = gender,
Counter_Location = counter_loc,
t_enter= t_0_iter
) %>%
ungroup()
# combination of all possible t_0
final_data_df <- bind_rows(final_data_df, temp_t_0_df)
}
# calculate the dose and the response
# and store the parameter values
dose_response_df <- final_data_df %>%
mutate(
Breath_Rate = breath,
Vol_Faeces = vol_faeces,
rho = rho,
f = f,
Dose = Drop_Vol_Ratio * breath * rho * vol_faeces * 1000 * pi/ (6 * 6 * f),
Response = doseResponse(Dose), # either exponential or beta-poisson depending on norovirus or sars
)
setwd(save_wd) # change wd to where the output csv will be saved
# write to file
write.table(dose_response_df, paste0(tolower(gender),"_",tolower(arrangement),"_",tolower(counter_loc),".csv"), sep = ",", col.names = TRUE, row.names = FALSE)
##############################################################################
### Plots for the infection risk for counter A and B                       ###
### Plots infection risk for SARS-CoV-2 and norovirus                      ###
### i.e. generates 4 plots with violins for male/female                    ###
### Need to run dose_response_monte_carlo.R first for all combinations     ###
###                                                                        ###
### Ciara A. Higham 07/03/23 - JHI paper                                   ###
##############################################################################
###############################
###        Pre-lims         ###
###############################
#install.packages("ggh4x")
#install.packages("ggplot2")
library(ggh4x)
library(ggplot2)
##############################################################################################################
##############################################################################################################
# The following blocks of code extend ggplot2 GeomViolin and make adjustments to add quantiles to the plot
# see stackoverflow (https://stackoverflow.com/questions/35717353/split-violin-plot-with-ggplot2) (@jan-glx, @Axeman)
# and stackoverflow (https://stackoverflow.com/questions/47651868/split-violin-plot-with-ggplot2-with-quantiles) (@Axeman)
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin,
draw_group = function(self, data, ..., draw_quantiles = NULL) {
data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
grp <- data[1, "group"]
newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])
if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 1))
quantiles <- create_quantile_segment_frame(data, draw_quantiles, split = TRUE, grp = grp)
aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
aesthetics$alpha <- rep(1, nrow(quantiles))
both <- cbind(quantiles, aesthetics)
quantile_grob <- GeomPath$draw_panel(both, ...)
ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
}
else {
ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
}
}
)
create_quantile_segment_frame <- function(data, draw_quantiles, split = FALSE, grp = NULL) {
dens <- cumsum(data$density) / sum(data$density)
ecdf <- stats::approxfun(dens, data$y)
ys <- ecdf(draw_quantiles)
violin.xminvs <- (stats::approxfun(data$y, data$xminv))(ys)
violin.xmaxvs <- (stats::approxfun(data$y, data$xmaxv))(ys)
violin.xs <- (stats::approxfun(data$y, data$x))(ys)
if (grp %% 2 == 0) {
data.frame(
x = ggplot2:::interleave(violin.xs, violin.xmaxvs),
y = rep(ys, each = 2), group = rep(ys, each = 2)
)
} else {
data.frame(
x = ggplot2:::interleave(violin.xminvs, violin.xs),
y = rep(ys, each = 2), group = rep(ys, each = 2)
)
}
}
geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ...,
draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE,
show.legend = NA, inherit.aes = TRUE) {
layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin, position = position,
show.legend = show.legend, inherit.aes = inherit.aes,
params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}
##############################################################################################################
##############################################################################################################
# comment out counter_a/counter_b, SARS/Norovirus
counter_loc = "counter_a"
#counter_loc = "counter_b"
#pathogen = "SARS-CoV-2"
pathogen = "Norovirus"
# comparison times
t1 <- "0"
t2 <- "60"
t3 <- "240"
current_wd <- dirname(rstudioapi::getActiveDocumentContext()$path) # find current wd
# wd for dose response data from dose_response_monte_carlo.R
# and wd for location to save file
if (pathogen == "SARS-CoV-2"){
data_wd <- paste0(current_wd,"/dose_response_output/sars_cov_2/")
save_wd <- paste0(current_wd,"/plots/infection_risk/sars_cov_2/")
file_name <- "sars_cov_2"
} else if (pathogen == "Norovirus"){
data_wd <- paste0(current_wd,"/dose_response_output/norovirus/")
save_wd <- paste0(current_wd,"/plots/infection_risk/norovirus/")
file_name <- "norovirus"
}
setwd(data_wd) # set to relavant dose-response data wd
# read in the dose-response data
if (counter_loc == "counter_a"){
male_S1 <- read.csv("male_S1_counter_a.csv",header = TRUE)
male_S2 <- read.csv("male_S2_counter_a.csv",header = TRUE)
female_S1 <- read.csv("female_S1_counter_a.csv",header = TRUE)
female_S2 <- read.csv("female_S2_counter_a.csv",header = TRUE)
file_name <- paste0(file_name, "_counter_a.png")
} else if (counter_loc == "counter_b"){
male_S1 <- read.csv("male_S1_counter_b.csv",header = TRUE)
male_S2 <- read.csv("male_S2_counter_b.csv",header = TRUE)
female_S1 <- read.csv("female_S1_counter_b.csv",header = TRUE)
female_S2 <- read.csv("female_S2_counter_b.csv",header = TRUE)
file_name <- paste0(file_name, "_counter_b.png")
}
# list of the new strip labels
strip_labels_new <- c("1.5 ACH" , "3 ACH" , "6 ACH" , paste(t1, "s"), paste(t2, "s"), paste(t3, "s"), "S2", "S1")
# list of the current labels
strip_labels_current <- c("1.5", "3", "6", t1, t2, t3, "S2", "S1")
# set the strip_labels to the new strip labels
strip_labels <- setNames(strip_labels_new, strip_labels_current)
# combine all 4 sets of data
combined <- rbind(female_S1,female_S2, male_S1, male_S2)
# filter by the relevant t_enter
filtered_combined <- subset(combined, t_enter %in% c(as.numeric(t1), as.numeric(t2), as.numeric(t3)))
# set the colour for female
filtered_combined$fill_color <- ifelse(filtered_combined$Gender == "Female", "#009ADE", "#FF1F5B")
# convert the risk to a percentage
filtered_combined$Response <- filtered_combined$Response * 100
# # change "no S2" to S1 and "S2 to S2 (scenario 1/2)
# filtered_combined$Arrangement <- ifelse(filtered_combined$Arrangement == "S1", "S1",
#                                         ifelse(filtered_combined$Arrangement == "S2", "S2",
#                                                filtered_combined$Arrangement))
# create the plot
p <- ggplot() +
# create the split violin plot
geom_split_violin(data = filtered_combined, # select the data to plot
aes(x = Arrangement, y = Response, fill = fill_color), # x axis is by arrangement
draw_quantiles = c(0.25, 0.5, 0.75), # 25th, 50th and 75th quantile
alpha = 0.8, size = 0.15) +
# nest the facets it is split by ACH, then split by t_enter, then split by S1/S2
# and add the labels
facet_nested(. ~ ACH + t_enter + Arrangement, scales = "free", labeller = as_labeller(strip_labels)) +
# plot on a log scale,
scale_y_log10(limits = c(3.8e-11, 100), breaks = c(1e-10, 1e-8,1e-6, 1e-4,1e-2,1,100), labels=c(expression(10^{-10}) ,expression(10^{-8}), expression(10^{-6}), expression(10^{-4}), expression(10^{-2}),  "1", "100"))+
theme_bw() +
# colours for the violin
scale_fill_manual(values = c( "#009ADE","#FF1F5B"), labels = c("Female", "Male"), name = NULL, guide = "legend") +
scale_x_discrete(breaks = NULL) + # remove x breaks
# aesthetics for the plot text size etc
theme(
text = element_text(family = "Arial"), # arial font
axis.text = element_text(size = 8),
strip.text = element_text(size = 6, margin = margin(2.65, 0.5, 2.65, 0.5)),
strip.background = element_rect(color = "black", size = 0.2),
legend.position = "bottom",
legend.text = element_text(size=6),
panel.border = element_blank(),
axis.title.x = element_blank(),
axis.text.x = element_blank(),
legend.margin=margin(0.01,0.1,0.01,0.1),
legend.key.size = unit(0.3, 'cm'),
) +
# y label
ylab("Risk (%)")
# print plot
print(p)
setwd(save_wd) # set save wd
# save plot
ggsave(file_name, plot = p, width = 18, height = 7, units = "cm")
##############################################################################
### Plots for the infection risk for counter A and B                       ###
### Plots infection risk for SARS-CoV-2 and norovirus                      ###
### i.e. generates 4 plots with violins for male/female                    ###
### Need to run dose_response_monte_carlo.R first for all combinations     ###
###                                                                        ###
### Ciara A. Higham 07/03/23 - JHI paper                                   ###
##############################################################################
###############################
###        Pre-lims         ###
###############################
#install.packages("ggh4x")
#install.packages("ggplot2")
library(ggh4x)
library(ggplot2)
##############################################################################################################
##############################################################################################################
# The following blocks of code extend ggplot2 GeomViolin and make adjustments to add quantiles to the plot
# see stackoverflow (https://stackoverflow.com/questions/35717353/split-violin-plot-with-ggplot2) (@jan-glx, @Axeman)
# and stackoverflow (https://stackoverflow.com/questions/47651868/split-violin-plot-with-ggplot2-with-quantiles) (@Axeman)
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin,
draw_group = function(self, data, ..., draw_quantiles = NULL) {
data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
grp <- data[1, "group"]
newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])
if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 1))
quantiles <- create_quantile_segment_frame(data, draw_quantiles, split = TRUE, grp = grp)
aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
aesthetics$alpha <- rep(1, nrow(quantiles))
both <- cbind(quantiles, aesthetics)
quantile_grob <- GeomPath$draw_panel(both, ...)
ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
}
else {
ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
}
}
)
create_quantile_segment_frame <- function(data, draw_quantiles, split = FALSE, grp = NULL) {
dens <- cumsum(data$density) / sum(data$density)
ecdf <- stats::approxfun(dens, data$y)
ys <- ecdf(draw_quantiles)
violin.xminvs <- (stats::approxfun(data$y, data$xminv))(ys)
violin.xmaxvs <- (stats::approxfun(data$y, data$xmaxv))(ys)
violin.xs <- (stats::approxfun(data$y, data$x))(ys)
if (grp %% 2 == 0) {
data.frame(
x = ggplot2:::interleave(violin.xs, violin.xmaxvs),
y = rep(ys, each = 2), group = rep(ys, each = 2)
)
} else {
data.frame(
x = ggplot2:::interleave(violin.xminvs, violin.xs),
y = rep(ys, each = 2), group = rep(ys, each = 2)
)
}
}
geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ...,
draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE,
show.legend = NA, inherit.aes = TRUE) {
layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin, position = position,
show.legend = show.legend, inherit.aes = inherit.aes,
params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}
##############################################################################################################
##############################################################################################################
# comment out counter_a/counter_b, SARS/Norovirus
#counter_loc = "counter_a"
counter_loc = "counter_b"
#pathogen = "SARS-CoV-2"
pathogen = "Norovirus"
# comparison times
t1 <- "0"
t2 <- "60"
t3 <- "240"
current_wd <- dirname(rstudioapi::getActiveDocumentContext()$path) # find current wd
# wd for dose response data from dose_response_monte_carlo.R
# and wd for location to save file
if (pathogen == "SARS-CoV-2"){
data_wd <- paste0(current_wd,"/dose_response_output/sars_cov_2/")
save_wd <- paste0(current_wd,"/plots/infection_risk/sars_cov_2/")
file_name <- "sars_cov_2"
} else if (pathogen == "Norovirus"){
data_wd <- paste0(current_wd,"/dose_response_output/norovirus/")
save_wd <- paste0(current_wd,"/plots/infection_risk/norovirus/")
file_name <- "norovirus"
}
setwd(data_wd) # set to relavant dose-response data wd
# read in the dose-response data
if (counter_loc == "counter_a"){
male_S1 <- read.csv("male_S1_counter_a.csv",header = TRUE)
male_S2 <- read.csv("male_S2_counter_a.csv",header = TRUE)
female_S1 <- read.csv("female_S1_counter_a.csv",header = TRUE)
female_S2 <- read.csv("female_S2_counter_a.csv",header = TRUE)
file_name <- paste0(file_name, "_counter_a.png")
} else if (counter_loc == "counter_b"){
male_S1 <- read.csv("male_S1_counter_b.csv",header = TRUE)
male_S2 <- read.csv("male_S2_counter_b.csv",header = TRUE)
female_S1 <- read.csv("female_S1_counter_b.csv",header = TRUE)
female_S2 <- read.csv("female_S2_counter_b.csv",header = TRUE)
file_name <- paste0(file_name, "_counter_b.png")
}
# list of the new strip labels
strip_labels_new <- c("1.5 ACH" , "3 ACH" , "6 ACH" , paste(t1, "s"), paste(t2, "s"), paste(t3, "s"), "S2", "S1")
# list of the current labels
strip_labels_current <- c("1.5", "3", "6", t1, t2, t3, "S2", "S1")
# set the strip_labels to the new strip labels
strip_labels <- setNames(strip_labels_new, strip_labels_current)
# combine all 4 sets of data
combined <- rbind(female_S1,female_S2, male_S1, male_S2)
# filter by the relevant t_enter
filtered_combined <- subset(combined, t_enter %in% c(as.numeric(t1), as.numeric(t2), as.numeric(t3)))
# set the colour for female
filtered_combined$fill_color <- ifelse(filtered_combined$Gender == "Female", "#009ADE", "#FF1F5B")
# convert the risk to a percentage
filtered_combined$Response <- filtered_combined$Response * 100
# # change "no S2" to S1 and "S2 to S2 (scenario 1/2)
# filtered_combined$Arrangement <- ifelse(filtered_combined$Arrangement == "S1", "S1",
#                                         ifelse(filtered_combined$Arrangement == "S2", "S2",
#                                                filtered_combined$Arrangement))
# create the plot
p <- ggplot() +
# create the split violin plot
geom_split_violin(data = filtered_combined, # select the data to plot
aes(x = Arrangement, y = Response, fill = fill_color), # x axis is by arrangement
draw_quantiles = c(0.25, 0.5, 0.75), # 25th, 50th and 75th quantile
alpha = 0.8, size = 0.15) +
# nest the facets it is split by ACH, then split by t_enter, then split by S1/S2
# and add the labels
facet_nested(. ~ ACH + t_enter + Arrangement, scales = "free", labeller = as_labeller(strip_labels)) +
# plot on a log scale,
scale_y_log10(limits = c(3.8e-11, 100), breaks = c(1e-10, 1e-8,1e-6, 1e-4,1e-2,1,100), labels=c(expression(10^{-10}) ,expression(10^{-8}), expression(10^{-6}), expression(10^{-4}), expression(10^{-2}),  "1", "100"))+
theme_bw() +
# colours for the violin
scale_fill_manual(values = c( "#009ADE","#FF1F5B"), labels = c("Female", "Male"), name = NULL, guide = "legend") +
scale_x_discrete(breaks = NULL) + # remove x breaks
# aesthetics for the plot text size etc
theme(
text = element_text(family = "Arial"), # arial font
axis.text = element_text(size = 8),
strip.text = element_text(size = 6, margin = margin(2.65, 0.5, 2.65, 0.5)),
strip.background = element_rect(color = "black", size = 0.2),
legend.position = "bottom",
legend.text = element_text(size=6),
panel.border = element_blank(),
axis.title.x = element_blank(),
axis.text.x = element_blank(),
legend.margin=margin(0.01,0.1,0.01,0.1),
legend.key.size = unit(0.3, 'cm'),
) +
# y label
ylab("Risk (%)")
# print plot
print(p)
setwd(save_wd) # set save wd
# save plot
ggsave(file_name, plot = p, width = 18, height = 7, units = "cm")
##############################################################################
### Plots for the particle concentration for counter A and B               ###
###                                                                        ###
### Ciara A. Higham 07/03/23 - JHI paper                                   ###
##############################################################################
###############################
###        Pre-lims         ###
###############################
#install.packages("ggplot2")
#install.packages("tidyr")
#install.packages("dplyr")
#install.packages("reshape2")
#install.packages("ggh4x")
library(ggplot2)
library(tidyr)
library(dplyr)
library(reshape2)
library(ggh4x)
###############################
###     Input parameters    ###
###############################
# comment out the relevant counter_loc
#counter_loc = "counter_a"
counter_loc = "counter_b"
# colors for the S2 vs S1
colors <- c(  "#af58ba", "#00cd6c")
# labels for the particle sizes
strip_labels <- c("0.3"="0.3 micron", "0.5"="0.5 micron", "1"="1 micron","3"= "3 micron", "5"="5 micron","10"= "10 micron")
#######################################
### Read in the experimental data #####
#######################################
# define file names and ACH values
file_names <- c("1.5ach-a.txt", "1.5ach-b.txt", "1.5ach-c.txt",
"3ach-a.txt", "3ach-b.txt", "3ach-c.txt",
"6ach-a.txt", "6ach-b.txt", "6ach-c.txt")
# ach values
ach_values <- c(1.5, 3, 6)
#current wd
current_wd <- dirname(rstudioapi::getActiveDocumentContext()$path)
inc = 5e3 # the amount by which the data is shifted - allows two scales
limits = c(inc,2e+7) # limits of plot
breaks = c(inc,1e+5+inc, 1e6+inc, 1e7+inc) # divisions on y axis
labels = c("0", expression(10^5), expression(10^6), expression(10^7))
conc_dist_df <- data.frame() # data frame for c_{i,j,t}
# plot both S2 and S1 scenario on same plot
for (arr in c("S2", "S1")){
# set the wd to where the data is located
if(arr == "S2"){
wd <- paste0(current_wd,"/raw_data/S2")
} else if(arr == "S1"){
wd <- paste0(current_wd,"/raw_data/S1")
}
if(counter_loc == "counter_a"){
wd <- paste0(wd, "/counter_a")
save_wd <- paste0(current_wd,"/plots/particle_conc/counter_a")
} else if(counter_loc == "counter_b"){
wd <- paste0(wd, "/counter_b")
save_wd <- paste0(current_wd,"/plots/particle_conc/counter_b")
}
setwd(wd)
# read in file
file_data <- lapply(file_names, read.table, header = TRUE)
for (ach in ach_values) { # iterate over 1.5, 3 and 6 ACH
temp_post_flush <- data.frame() # temp list to store the post-flush data frames
# read in data file
ach_files <- file_names[grep(paste0(ach, "ach-"), file_names)] # filter file to the corresponding ach in loop
for (i in 1:3) { # loop through the replicates for each ach
data <- file_data[[which(file_names == ach_files[i])]]
pre_flush_rows <- data[892:921, ] # data 5 minutes pre-flush
post_flush_rows <- data[922:nrow(data), ] # data post-flush
colnames(post_flush_rows) <- c("0.3", "0.5", "1", "3", "5", "10") # column names to particle sizes
bckg_conc_df <- apply(pre_flush_rows, 2, median) # assign median to data frame
for (j in 1:6) { # remove background for each size
post_flush_rows[, j] <- post_flush_rows[, j] - bckg_conc_df[j]
}
post_flush_rows[post_flush_rows <= 0] <- 0 # if < 0 set to 0
post_flush_rows$Time <- seq(1, nrow(post_flush_rows)) * 10 # time post-flush column
max_time <- max(post_flush_rows$Time) # max time of post-flush data i.e. when counter stops running
if (max_time > 1500) { # if max time is greater than 25 mins
valid_rows <- post_flush_rows$Time <= 1500 # just keep data up to 25 mins
post_flush_rows <- post_flush_rows[valid_rows, ]
} else if (max_time < 1500) { # if the counter was stopped before 25 mins
new_times <- seq(max_time + 10, 1500, by = 10) #
new_rows <- data.frame(Time = new_times)
new_rows[, c("0.3", "0.5", "1", "3", "5", "10")] <- 0 # set the values after the max time but before 25 min to zero
post_flush_rows <- rbind(post_flush_rows, new_rows)
}
post_flush_rows$ACH <- rep(ach, nrow(post_flush_rows)) # add ACH column
post_flush_rows$Replicate <- rep(i, nrow(post_flush_rows)) # add a column indicating replicate number
# melt so that there is a column for size
post_flush_rows <- melt(post_flush_rows, id.vars = c("Replicate", "Time", "ACH"))
colnames(post_flush_rows)[4] <- "Size" # name size col
colnames(post_flush_rows)[5] <- "Conc" # name conc col
post_flush_rows$Arrangment<- arr # column for S2/S1 scenario
temp_post_flush <- bind_rows(temp_post_flush, post_flush_rows) # combine data for each replicate
}
conc_dist_df <- bind_rows(conc_dist_df, temp_post_flush) # combine each ACH frame
}
}
# calculate mean and standard error across replicates
plot_df <- conc_dist_df %>%
group_by(Time, ACH, Size, Arrangment)%>%
summarise(Mean_Conc = mean(Conc) + inc, # add inc to readjust the scale
SE_Mean_Conc = sd(Conc) / sqrt(n()))
setwd(save_wd)
plots <- lapply(unique(plot_df$ACH), function(ach_value) { # plot for each ACH
subset_data <- subset(plot_df, ACH == ach_value) # select data for relevant ACH
p <- ggplot(data = subset(plot_df, ACH == ach_value), aes(x = Time, y = Mean_Conc, group = Arrangment)) +
# plot standard error as a ribbon
geom_ribbon(aes(ymin = Mean_Conc - SE_Mean_Conc, ymax = Mean_Conc + SE_Mean_Conc, fill = factor(Arrangment)), alpha = 0.4, show.legend = FALSE) +
# plot mean_conc as a line for both arrangements
geom_line(aes(color = factor(Arrangment)), size = 0.25)  +
# colours for the plot
scale_color_manual(values = colors) +
scale_fill_manual(values = colors) +
# change x scale between 0-10 mins and change to mins
scale_x_continuous(limits = c(0,600), breaks = seq(0, 1500, by = 60),
labels = seq(0, 1500, by = 60)/60, minor_breaks = seq(0, 1500, by = 30)) +
# add labels
labs(x = "Time post flush (min)",
y = "Concentration (#/m³)",
fill = "Particle Size") +
theme_bw() +
# aesthetics eg text size etc
theme(text = element_text(family = "Arial"),
axis.text = element_text(size = 7),
strip.text = element_text(size = 7),
axis.title = element_text(size = 7),
legend.position = "bottom",
legend.text = element_text(size=7),
plot.title = element_blank(),
legend.title = element_blank(),
panel.border = element_blank(),
legend.margin=margin(c(0.01,0.01,0.01,0.1)),
legend.key.size = unit(0.4, 'cm')) +
# facets for each particle size
facet_wrap(~factor(Size), scales = "free", labeller = as_labeller(strip_labels))+
# all on the same scale and remove the scales for 0.5, 1, 5, 10 micron sizes
facetted_pos_scales(y = list(scale_y_log10(limits = limits, breaks = breaks,
labels = labels),
scale_y_log10(limits = limits,breaks = breaks, guide = "none"),
scale_y_log10(limits = limits,breaks = breaks, guide = "none"),
scale_y_log10(limits = limits,breaks = breaks,
labels = labels),
scale_y_log10(limits = limits,breaks = breaks, guide = "none"),
scale_y_log10(limits = limits,breaks = breaks, guide = "none")))
# save plot
ggsave(filename = paste0(ach_value, "_ACH.png"), plot = p, width = 18, height = 8, units = "cm")
# print plot
print(p)
return(p)
})
